#![feature(prelude_import)]
#![allow(clippy :: all)]
#![deny(unused_imports, unused_variables, unused_mut, clippy ::
unnecessary_mut_passed, unused_results)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

use clap::Parser;
use cmd_arg::CmdArgs;

use sys::Sys;
use tracing_subscriber::{
    prelude::__tracing_subscriber_SubscriberExt, util::SubscriberInitExt,
    Layer,
};

// #[macro_use]
// pub mod module_view;
pub mod cmd_arg {
    // pub mod module_iter;
    // pub mod module_state_trans;
    // inlcude macro logical_module

    // Include the `items` module, which is generated from items.proto.

    // println!("{}", v.module_path().unwrap());
    // println!("{}", v.name());
    // if v.module_path().unwrap().contains("quinn_proto") {
    //     return false;
    // }

    // if v.module_path().unwrap().contains("qp2p::wire_msg") {
    //     return false;
    // }

    // println!("{}", v.target());
    // if v.module_path().unwrap().contains("async_raft") {
    //     return false;
    // }

    // if v.module_path().unwrap().contains("less::network::p2p") {
    //     return false;
    // }

    // v.level() == &tracing::Level::ERROR
    //     || v.level() == &tracing::Level::WARN
    //     || v.level() == &tracing::Level::INFO
    // v.level() == &tracing::Level::TRACE
    // true

    // tracing_subscriber::fmt::init();

    // dist_kv_raft::tikvraft_proxy::start();
    use clap::Parser;
    /// Simple program to greet a person
    pub struct CmdArgs {
        /// Name of the person to greet
        pub config_file: String,
    }
    impl clap::Parser for CmdArgs {}
    #[allow(dead_code, unreachable_code, unused_variables, unused_braces)]
    #[allow(clippy :: style, clippy :: complexity, clippy :: pedantic, clippy
    :: restriction, clippy :: perf, clippy :: deprecated, clippy :: nursery,
    clippy :: cargo, clippy :: suspicious_else_formatting, clippy ::
    almost_swapped,)]
    #[allow(deprecated)]
    impl clap::CommandFactory for CmdArgs {
        fn into_app<'b>() -> clap::Command<'b> {
            let __clap_app = clap::Command::new("wasm_serverless");
            <Self as clap::Args>::augment_args(__clap_app)
        }
        fn into_app_for_update<'b>() -> clap::Command<'b> {
            let __clap_app = clap::Command::new("wasm_serverless");
            <Self as clap::Args>::augment_args_for_update(__clap_app)
        }
    }
    #[allow(dead_code, unreachable_code, unused_variables, unused_braces)]
    #[allow(clippy :: style, clippy :: complexity, clippy :: pedantic, clippy
    :: restriction, clippy :: perf, clippy :: deprecated, clippy :: nursery,
    clippy :: cargo, clippy :: suspicious_else_formatting, clippy ::
    almost_swapped,)]
    impl clap::FromArgMatches for CmdArgs {
        fn from_arg_matches(__clap_arg_matches: &clap::ArgMatches)
            -> ::std::result::Result<Self, clap::Error> {
            Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn from_arg_matches_mut(__clap_arg_matches: &mut clap::ArgMatches)
            -> ::std::result::Result<Self, clap::Error> {
            #![allow(deprecated)]
            let v =
                CmdArgs {
                    config_file: __clap_arg_matches.get_one::<String>("config-file").map(|s|
                                        ::std::ops::Deref::deref(s)).ok_or_else(||
                                    clap::Error::raw(clap::ErrorKind::MissingRequiredArgument,
                                        {
                                            let res =
                                                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["The following required argument was not provided: "],
                                                        &[::core::fmt::ArgumentV1::new_display(&"config-file")]));
                                            res
                                        })).and_then(|s|
                                ::std::str::FromStr::from_str(s).map_err(|err|
                                        clap::Error::raw(clap::ErrorKind::ValueValidation,
                                            {
                                                let res =
                                                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["Invalid value for ",
                                                                        ": "],
                                                            &[::core::fmt::ArgumentV1::new_display(&"config-file"),
                                                                        ::core::fmt::ArgumentV1::new_display(&err)]));
                                                res
                                            })))?,
                };
            ::std::result::Result::Ok(v)
        }
        fn update_from_arg_matches(&mut self,
            __clap_arg_matches: &clap::ArgMatches)
            -> ::std::result::Result<(), clap::Error> {
            self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
        }
        fn update_from_arg_matches_mut(&mut self,
            __clap_arg_matches: &mut clap::ArgMatches)
            -> ::std::result::Result<(), clap::Error> {
            #![allow(deprecated)]
            if __clap_arg_matches.contains_id("config-file") {
                    #[allow(non_snake_case)]
                    let config_file = &mut self.config_file;
                    *config_file =
                        __clap_arg_matches.get_one::<String>("config-file").map(|s|
                                            ::std::ops::Deref::deref(s)).ok_or_else(||
                                        clap::Error::raw(clap::ErrorKind::MissingRequiredArgument,
                                            {
                                                let res =
                                                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["The following required argument was not provided: "],
                                                            &[::core::fmt::ArgumentV1::new_display(&"config-file")]));
                                                res
                                            })).and_then(|s|
                                    ::std::str::FromStr::from_str(s).map_err(|err|
                                            clap::Error::raw(clap::ErrorKind::ValueValidation,
                                                {
                                                    let res =
                                                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["Invalid value for ",
                                                                            ": "],
                                                                &[::core::fmt::ArgumentV1::new_display(&"config-file"),
                                                                            ::core::fmt::ArgumentV1::new_display(&err)]));
                                                    res
                                                })))?
                }
            ::std::result::Result::Ok(())
        }
    }
    #[allow(dead_code, unreachable_code, unused_variables, unused_braces)]
    #[allow(clippy :: style, clippy :: complexity, clippy :: pedantic, clippy
    :: restriction, clippy :: perf, clippy :: deprecated, clippy :: nursery,
    clippy :: cargo, clippy :: suspicious_else_formatting, clippy ::
    almost_swapped,)]
    impl clap::Args for CmdArgs {
        fn augment_args<'b>(__clap_app: clap::Command<'b>)
            -> clap::Command<'b> {
            {
                let __clap_app = __clap_app;
                let __clap_app =
                    __clap_app.arg({
                            #[allow(deprecated)]
                            let arg =
                                clap::Arg::new("config-file").takes_value(true).value_name("CONFIG_FILE").required(true
                                                    &&
                                                    clap::ArgAction::StoreValue.takes_values()).validator(|s|
                                                {
                                                    ::std::str::FromStr::from_str(s).map(|_: String| ())
                                                }).value_parser(clap::builder::ValueParser::string()).action(clap::ArgAction::StoreValue);
                            let arg =
                                arg.help("Name of the person to greet").long_help(None);
                            arg
                        });
                __clap_app.about("Simple program to greet a person").long_about(None)
            }
        }
        fn augment_args_for_update<'b>(__clap_app: clap::Command<'b>)
            -> clap::Command<'b> {
            {
                let __clap_app = __clap_app;
                let __clap_app =
                    __clap_app.arg({
                            #[allow(deprecated)]
                            let arg =
                                clap::Arg::new("config-file").takes_value(true).value_name("CONFIG_FILE").required(false
                                                    &&
                                                    clap::ArgAction::StoreValue.takes_values()).validator(|s|
                                                {
                                                    ::std::str::FromStr::from_str(s).map(|_: String| ())
                                                }).value_parser(clap::builder::ValueParser::string()).action(clap::ArgAction::StoreValue);
                            let arg =
                                arg.help("Name of the person to greet").long_help(None);
                            arg
                        });
                __clap_app.about("Simple program to greet a person").long_about(None)
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CmdArgs {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(f, "CmdArgs",
                "config_file", &&self.config_file)
        }
    }
}
pub mod config {
    use serde::{Deserialize, Serialize};
    use std::{net::SocketAddr, path::Path};
    use crate::sys::NodeID;
    pub struct Config {
        pub peers: Vec<(SocketAddr, NodeID)>,
        pub this: (SocketAddr, NodeID),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Config {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f, "Config",
                "peers", &&self.peers, "this", &&self.this)
        }
    }
    pub struct YamlConfig {
        nodes: Vec<SocketAddr>,
        this: SocketAddr,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for YamlConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(f,
                "YamlConfig", "nodes", &&self.nodes, "this", &&self.this)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for YamlConfig {
                fn serialize<__S>(&self, __serializer: __S)
                    -> _serde::__private::Result<__S::Ok, __S::Error> where
                    __S: _serde::Serializer {
                    let mut __serde_state =
                        _serde::Serializer::serialize_struct(__serializer,
                                "YamlConfig", false as usize + 1 + 1)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "nodes", &self.nodes)?;
                    _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,
                            "this", &self.this)?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () =
        {
            #[allow(unused_extern_crates, clippy :: useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for YamlConfig {
                fn deserialize<__D>(__deserializer: __D)
                    -> _serde::__private::Result<Self, __D::Error> where
                    __D: _serde::Deserializer<'de> {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field { __field0, __field1, __ignore, }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "field identifier")
                        }
                        fn visit_u64<__E>(self, __value: u64)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(self, __value: &str)
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                "nodes" => _serde::__private::Ok(__Field::__field0),
                                "this" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                        fn visit_bytes<__E>(self, __value: &[u8])
                            -> _serde::__private::Result<Self::Value, __E> where
                            __E: _serde::de::Error {
                            match __value {
                                b"nodes" => _serde::__private::Ok(__Field::__field0),
                                b"this" => _serde::__private::Ok(__Field::__field1),
                                _ => { _serde::__private::Ok(__Field::__ignore) }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(__deserializer: __D)
                            -> _serde::__private::Result<Self, __D::Error> where
                            __D: _serde::Deserializer<'de> {
                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                __FieldVisitor)
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<YamlConfig>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = YamlConfig;
                        fn expecting(&self,
                            __formatter: &mut _serde::__private::Formatter)
                            -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter,
                                "struct YamlConfig")
                        }
                        #[inline]
                        fn visit_seq<__A>(self, mut __seq: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::SeqAccess<'de> {
                            let __field0 =
                                match _serde::de::SeqAccess::next_element::<Vec<SocketAddr>>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(0usize,
                                                    &"struct YamlConfig with 2 elements")),
                                };
                            let __field1 =
                                match _serde::de::SeqAccess::next_element::<SocketAddr>(&mut __seq)?
                                    {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None =>
                                        return _serde::__private::Err(_serde::de::Error::invalid_length(1usize,
                                                    &"struct YamlConfig with 2 elements")),
                                };
                            _serde::__private::Ok(YamlConfig {
                                    nodes: __field0,
                                    this: __field1,
                                })
                        }
                        #[inline]
                        fn visit_map<__A>(self, mut __map: __A)
                            -> _serde::__private::Result<Self::Value, __A::Error> where
                            __A: _serde::de::MapAccess<'de> {
                            let mut __field0:
                                    _serde::__private::Option<Vec<SocketAddr>> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<SocketAddr> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                    _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("nodes"));
                                            }
                                        __field0 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<Vec<SocketAddr>>(&mut __map)?);
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(<__A::Error as
                                                                _serde::de::Error>::duplicate_field("this"));
                                            }
                                        __field1 =
                                            _serde::__private::Some(_serde::de::MapAccess::next_value::<SocketAddr>(&mut __map)?);
                                    }
                                    _ => {
                                        let _ =
                                            _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 =
                                match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("nodes")?,
                                };
                            let __field1 =
                                match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None =>
                                        _serde::__private::de::missing_field("this")?,
                                };
                            _serde::__private::Ok(YamlConfig {
                                    nodes: __field0,
                                    this: __field1,
                                })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["nodes", "this"];
                    _serde::Deserializer::deserialize_struct(__deserializer,
                        "YamlConfig", FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<YamlConfig>,
                            lifetime: _serde::__private::PhantomData,
                        })
                }
            }
        };
    pub fn read_config(file_path: impl AsRef<Path>) -> Config {
        let file =
            std::fs::File::open(file_path).unwrap_or_else(|err|
                    {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["open config file failed, err: "],
                                &[::core::fmt::ArgumentV1::new_debug(&err)]));
                    });
        let yaml_config: YamlConfig =
            serde_yaml::from_reader(file).unwrap_or_else(|e|
                    {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["parse yaml config file failed, err: "],
                                &[::core::fmt::ArgumentV1::new_debug(&e)]));
                    });
        let nodes_with_id_iter =
            ||
                {
                    yaml_config.nodes.iter().enumerate().map(|(i, v)|
                            (v.clone(), i as NodeID + 1))
                };
        Config {
            peers: nodes_with_id_iter().filter(|(v, _i)|
                        v != &yaml_config.this).collect(),
            this: nodes_with_id_iter().filter(|(v, _i)|
                                v == &yaml_config.this).next().unwrap().clone(),
        }
    }
}
pub mod error_collector {}
mod kv {
    pub mod dist_kv {
        use async_trait::async_trait;
        pub struct SetOptions {
            pub consistent: bool,
        }
        impl SetOptions {
            pub fn new() -> SetOptions { SetOptions { consistent: false } }
            pub fn set_consistent(mut self, consistent: bool) -> Self {
                self.consistent = consistent;
                self
            }
        }
        pub trait KVNode: Sync + Send + 'static {}
    }
    pub mod dist_kv_rscode {}
    pub mod kv_client {
        pub mod local_kv_client {
            use async_trait::async_trait;
            use ws_derive::LogicalModule;
            use crate::{
                kv::{dist_kv::SetOptions, KeyRange},
                result::WSResult,
                sys::{LogicalModule, LogicalModuleNewArgs, Sys},
                util::JoinHandleWrapper,
            };
            use super::KVClient;
            pub struct LocalKVClient {}
            impl LocalKVClient {
                pub fn new(args: LogicalModuleNewArgs) -> Self {
                    let ret = Self::inner_new(args);
                    ret
                }
                pub fn name() -> &'static str { "LocalKVClient" }
            }
            impl KVClient for LocalKVClient {
                #[allow(clippy :: async_yields_async, clippy ::
                diverging_sub_expression, clippy :: let_unit_value, clippy ::
                no_effect_underscore_binding, clippy :: shadow_same, clippy ::
                type_complexity, clippy :: type_repetition_in_bounds, clippy
                :: used_underscore_binding)]
                fn get<'a, 'life0,
                    'async_trait>(&'a self, _sys: &'life0 Sys,
                    _key_range: KeyRange<'a>)
                    ->
                        ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                        WSResult<Option<Vec<u8>>>> + ::core::marker::Send +
                        'async_trait>> where 'a: 'async_trait, 'life0: 'async_trait,
                    Self: 'async_trait {
                    Box::pin(async move
                            {
                            if let ::core::option::Option::Some(__ret) =
                                        ::core::option::Option::None::<WSResult<Option<Vec<u8>>>> {
                                    return __ret;
                                }
                            let __self = self;
                            let _key_range = _key_range;
                            let __ret: WSResult<Option<Vec<u8>>> = { Ok(None) };

                            #[allow(unreachable_code)]
                            __ret
                        })
                }
                #[allow(clippy :: async_yields_async, clippy ::
                diverging_sub_expression, clippy :: let_unit_value, clippy ::
                no_effect_underscore_binding, clippy :: shadow_same, clippy ::
                type_complexity, clippy :: type_repetition_in_bounds, clippy
                :: used_underscore_binding)]
                fn set<'life0, 'life1,
                    'async_trait>(&'life0 self, _sys: &'life1 Sys,
                    _kvs: Vec<(Vec<u8>, Vec<u8>)>, _opts: SetOptions)
                    ->
                        ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                        WSResult<Option<Vec<(Vec<u8>, Vec<u8>)>>>> +
                        ::core::marker::Send + 'async_trait>> where
                    'life0: 'async_trait, 'life1: 'async_trait,
                    Self: 'async_trait {
                    Box::pin(async move
                            {
                            if let ::core::option::Option::Some(__ret) =
                                        ::core::option::Option::None::<WSResult<Option<Vec<(Vec<u8>,
                                            Vec<u8>)>>>> {
                                    return __ret;
                                }
                            let __self = self;
                            let _kvs = _kvs;
                            let _opts = _opts;
                            let __ret: WSResult<Option<Vec<(Vec<u8>, Vec<u8>)>>> =
                                { Ok(None) };

                            #[allow(unreachable_code)]
                            __ret
                        })
                }
            }
            impl LogicalModule for LocalKVClient {
                fn inner_new(_args: LogicalModuleNewArgs) -> Self where
                    Self: Sized {
                    Self {}
                }
                #[allow(clippy :: async_yields_async, clippy ::
                diverging_sub_expression, clippy :: let_unit_value, clippy ::
                no_effect_underscore_binding, clippy :: shadow_same, clippy ::
                type_complexity, clippy :: type_repetition_in_bounds, clippy
                :: used_underscore_binding)]
                fn start<'life0, 'async_trait>(&'life0 self)
                    ->
                        ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                        WSResult<Vec<JoinHandleWrapper>>> + ::core::marker::Send +
                        'async_trait>> where 'life0: 'async_trait,
                    Self: 'async_trait {
                    Box::pin(async move
                            {
                            if let ::core::option::Option::Some(__ret) =
                                        ::core::option::Option::None::<WSResult<Vec<JoinHandleWrapper>>>
                                    {
                                    return __ret;
                                }
                            let __self = self;
                            let __ret: WSResult<Vec<JoinHandleWrapper>> =
                                { let all = ::alloc::vec::Vec::new(); Ok(all) };

                            #[allow(unreachable_code)]
                            __ret
                        })
                }
            }
        }
        pub mod meta_kv_client {
            use async_trait::async_trait;
            use ws_derive::LogicalModule;
            use super::KVClient;
            use crate::{
                kv::{dist_kv::SetOptions, KeyRange},
                result::WSResult,
                sys::{
                    LogicalModule, LogicalModuleNewArgs, MetaKVClientView, Sys,
                },
                util::JoinHandleWrapper,
            };
            pub struct MetaKVClient {
                view: MetaKVClientView,
            }
            impl MetaKVClient {
                pub fn new(args: LogicalModuleNewArgs) -> Self {
                    let ret = Self::inner_new(args);
                    ret
                }
                pub fn name() -> &'static str { "MetaKVClient" }
            }
            impl LogicalModule for MetaKVClient {
                fn inner_new(_args: LogicalModuleNewArgs) -> Self where
                    Self: Sized {
                    let view = MetaKVClientView::new();
                    MetaKVClient { view }
                }
                #[allow(clippy :: async_yields_async, clippy ::
                diverging_sub_expression, clippy :: let_unit_value, clippy ::
                no_effect_underscore_binding, clippy :: shadow_same, clippy ::
                type_complexity, clippy :: type_repetition_in_bounds, clippy
                :: used_underscore_binding)]
                fn start<'life0, 'async_trait>(&'life0 self)
                    ->
                        ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                        WSResult<Vec<JoinHandleWrapper>>> + ::core::marker::Send +
                        'async_trait>> where 'life0: 'async_trait,
                    Self: 'async_trait {
                    Box::pin(async move
                            {
                            if let ::core::option::Option::Some(__ret) =
                                        ::core::option::Option::None::<WSResult<Vec<JoinHandleWrapper>>>
                                    {
                                    return __ret;
                                }
                            let __self = self;
                            let __ret: WSResult<Vec<JoinHandleWrapper>> =
                                { let all = ::alloc::vec::Vec::new(); Ok(all) };

                            #[allow(unreachable_code)]
                            __ret
                        })
                }
            }
            impl KVClient for MetaKVClient {
                #[allow(clippy :: async_yields_async, clippy ::
                diverging_sub_expression, clippy :: let_unit_value, clippy ::
                no_effect_underscore_binding, clippy :: shadow_same, clippy ::
                type_complexity, clippy :: type_repetition_in_bounds, clippy
                :: used_underscore_binding)]
                fn get<'a, 'life0,
                    'async_trait>(&'a self, _sys: &'life0 Sys,
                    _key_range: KeyRange<'a>)
                    ->
                        ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                        WSResult<Option<Vec<u8>>>> + ::core::marker::Send +
                        'async_trait>> where 'a: 'async_trait, 'life0: 'async_trait,
                    Self: 'async_trait {
                    Box::pin(async move
                            {
                            if let ::core::option::Option::Some(__ret) =
                                        ::core::option::Option::None::<WSResult<Option<Vec<u8>>>> {
                                    return __ret;
                                }
                            let __self = self;
                            let _key_range = _key_range;
                            let __ret: WSResult<Option<Vec<u8>>> = { Ok(None) };

                            #[allow(unreachable_code)]
                            __ret
                        })
                }
                #[allow(clippy :: async_yields_async, clippy ::
                diverging_sub_expression, clippy :: let_unit_value, clippy ::
                no_effect_underscore_binding, clippy :: shadow_same, clippy ::
                type_complexity, clippy :: type_repetition_in_bounds, clippy
                :: used_underscore_binding)]
                fn set<'life0, 'life1,
                    'async_trait>(&'life0 self, _sys: &'life1 Sys,
                    _kvs: Vec<(Vec<u8>, Vec<u8>)>, _opts: SetOptions)
                    ->
                        ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                        WSResult<Option<Vec<(Vec<u8>, Vec<u8>)>>>> +
                        ::core::marker::Send + 'async_trait>> where
                    'life0: 'async_trait, 'life1: 'async_trait,
                    Self: 'async_trait {
                    Box::pin(async move
                            {
                            if let ::core::option::Option::Some(__ret) =
                                        ::core::option::Option::None::<WSResult<Option<Vec<(Vec<u8>,
                                            Vec<u8>)>>>> {
                                    return __ret;
                                }
                            let __self = self;
                            let _kvs = _kvs;
                            let _opts = _opts;
                            let __ret: WSResult<Option<Vec<(Vec<u8>, Vec<u8>)>>> =
                                { Ok(None) };

                            #[allow(unreachable_code)]
                            __ret
                        })
                }
            }
        }
        use super::{dist_kv::SetOptions, KeyRange};
        use crate::{result::WSResult, sys::Sys};
        use async_trait::async_trait;
        pub trait KVClient: Send + Sync + 'static {
            #[must_use]
            #[allow(clippy :: type_complexity, clippy ::
            type_repetition_in_bounds)]
            fn get<'a, 'life0,
            'async_trait>(&'a self, sys: &'life0 Sys, key_range: KeyRange<'a>)
            ->
                ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                WSResult<Option<Vec<u8>>>> + ::core::marker::Send +
                'async_trait>>
            where
            'a: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait;
            #[must_use]
            #[allow(clippy :: type_complexity, clippy ::
            type_repetition_in_bounds)]
            fn set<'life0, 'life1,
            'async_trait>(&'life0 self, sys: &'life1 Sys,
            kvs: Vec<(Vec<u8>, Vec<u8>)>, opts: SetOptions)
            ->
                ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                WSResult<Option<Vec<(Vec<u8>, Vec<u8>)>>>> +
                ::core::marker::Send + 'async_trait>>
            where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        }
    }
    pub mod local_kv {
        pub mod local_kv {
            use crate::{
                kv::dist_kv::KVNode, result::WSResult,
                sys::{LogicalModule, LogicalModuleNewArgs},
                util::JoinHandleWrapper,
            };
            use async_trait::async_trait;
            use ws_derive::LogicalModule;
            pub struct LocalKVNode {}
            impl LocalKVNode {
                pub fn new(args: LogicalModuleNewArgs) -> Self {
                    let ret = Self::inner_new(args);
                    ret
                }
                pub fn name() -> &'static str { "LocalKVNode" }
            }
            impl KVNode for LocalKVNode {}
            impl LogicalModule for LocalKVNode {
                fn inner_new(_args: LogicalModuleNewArgs) -> Self where
                    Self: Sized {
                    LocalKVNode {}
                }
                #[allow(clippy :: async_yields_async, clippy ::
                diverging_sub_expression, clippy :: let_unit_value, clippy ::
                no_effect_underscore_binding, clippy :: shadow_same, clippy ::
                type_complexity, clippy :: type_repetition_in_bounds, clippy
                :: used_underscore_binding)]
                fn start<'life0, 'async_trait>(&'life0 self)
                    ->
                        ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                        WSResult<Vec<JoinHandleWrapper>>> + ::core::marker::Send +
                        'async_trait>> where 'life0: 'async_trait,
                    Self: 'async_trait {
                    Box::pin(async move
                            {
                            if let ::core::option::Option::Some(__ret) =
                                        ::core::option::Option::None::<WSResult<Vec<JoinHandleWrapper>>>
                                    {
                                    return __ret;
                                }
                            let __self = self;
                            let __ret: WSResult<Vec<JoinHandleWrapper>> =
                                { let all = ::alloc::vec::Vec::new(); Ok(all) };

                            #[allow(unreachable_code)]
                            __ret
                        })
                }
            }
        }
        mod local_kv_kernel {
            use async_trait::async_trait;
            use crate::{kv::dist_kv::SetOptions, result::WSResult};
            pub trait LocalKVRaw: Send + Sync + 'static {
                #[must_use]
                #[allow(clippy :: type_complexity, clippy ::
                type_repetition_in_bounds)]
                fn get<'life0, 'life1, 'life2,
                'async_trait>(&'life0 self, key: &'life1 [u8],
                end: Option<&'life2 [u8]>)
                ->
                    ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                    WSResult<Vec<(Vec<u8>, Vec<u8>)>>> + ::core::marker::Send +
                    'async_trait>>
                where
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait;
                #[must_use]
                #[allow(clippy :: type_complexity, clippy ::
                type_repetition_in_bounds)]
                fn set<'life0, 'life1, 'life2, 'life3,
                'async_trait>(&'life0 self,
                kvs: &'life1 [(&'life2 [u8], &'life3 [u8])], opts: SetOptions)
                ->
                    ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
                    WSResult<Option<Vec<(Vec<u8>, Vec<u8>)>>>> +
                    ::core::marker::Send + 'async_trait>>
                where
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                'life3: 'async_trait,
                Self: 'async_trait;
            }
        }
        mod local_kv_sled {}
    }
    pub struct KeyRange<'a> {
        start: &'a [u8],
        end: Option<&'a [u8]>,
    }
}
pub mod network {
    pub mod msg_pack {
        use downcast_rs::{impl_downcast, Downcast};
        use super::{p2p::MsgId, proto};
        pub trait MsgPack: prost::Message + Downcast {
            fn msg_id(&self)
            -> MsgId;
        }
        impl dyn MsgPack<> {
            /// Returns true if the trait object wraps an object of type `__T`.
            #[inline]
            pub fn is<__T: MsgPack<>>(&self) -> bool {
                ::downcast_rs::Downcast::as_any(self).is::<__T>()
            }
            /// Returns a boxed object from a boxed trait object if the underlying object is of type
            /// `__T`. Returns the original boxed trait if it isn't.
            #[inline]
            pub fn downcast<__T: MsgPack<>>(self:
                    ::downcast_rs::__alloc::boxed::Box<Self>)
                ->
                    ::downcast_rs::__std::result::Result<::downcast_rs::__alloc::boxed::Box<__T>,
                    ::downcast_rs::__alloc::boxed::Box<Self>> {
                if self.is::<__T>() {
                        Ok(::downcast_rs::Downcast::into_any(self).downcast::<__T>().unwrap())
                    } else { Err(self) }
            }
            /// Returns an `Rc`-ed object from an `Rc`-ed trait object if the underlying object is of
            /// type `__T`. Returns the original `Rc`-ed trait if it isn't.
            #[inline]
            pub fn downcast_rc<__T: MsgPack<>>(self:
                    ::downcast_rs::__alloc::rc::Rc<Self>)
                ->
                    ::downcast_rs::__std::result::Result<::downcast_rs::__alloc::rc::Rc<__T>,
                    ::downcast_rs::__alloc::rc::Rc<Self>> {
                if self.is::<__T>() {
                        Ok(::downcast_rs::Downcast::into_any_rc(self).downcast::<__T>().unwrap())
                    } else { Err(self) }
            }
            /// Returns a reference to the object within the trait object if it is of type `__T`, or
            /// `None` if it isn't.
            #[inline]
            pub fn downcast_ref<__T: MsgPack<>>(&self)
                -> ::downcast_rs::__std::option::Option<&__T> {
                ::downcast_rs::Downcast::as_any(self).downcast_ref::<__T>()
            }
            /// Returns a mutable reference to the object within the trait object if it is of type
            /// `__T`, or `None` if it isn't.
            #[inline]
            pub fn downcast_mut<__T: MsgPack<>>(&mut self)
                -> ::downcast_rs::__std::option::Option<&mut __T> {
                ::downcast_rs::Downcast::as_any_mut(self).downcast_mut::<__T>()
            }
        }
        impl MsgPack for proto::raft::VoteRequest {
            fn msg_id(&self) -> MsgId { 0 }
        }
        impl MsgPack for proto::raft::VoteResponse {
            fn msg_id(&self) -> MsgId { 1 }
        }
        impl MsgPack for proto::raft::AppendEntriesRequest {
            fn msg_id(&self) -> MsgId { 2 }
        }
        impl MsgPack for proto::raft::AppendEntriesResponse {
            fn msg_id(&self) -> MsgId { 3 }
        }
        pub trait RPCReq: MsgPack {
            type Resp: MsgPack;
        }
        impl RPCReq for proto::raft::VoteRequest {
            type Resp = proto::raft::VoteResponse;
        }
        impl RPCReq for proto::raft::AppendEntriesRequest {
            type Resp = proto::raft::AppendEntriesResponse;
        }
    }
    pub mod p2p {
        pub type TaskId = u32;
        pub type MsgId = u32;
    }
    pub mod proto {
        pub mod kv {
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct KeyRange {
                #[prost(bytes = "vec", tag = "1")]
                pub start: ::prost::alloc::vec::Vec<u8>,
                #[prost(bytes = "vec", optional, tag = "2")]
                pub end: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for KeyRange {
                #[inline]
                fn clone(&self) -> KeyRange {
                    KeyRange {
                        start: ::core::clone::Clone::clone(&self.start),
                        end: ::core::clone::Clone::clone(&self.end),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for KeyRange { }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for KeyRange {
                #[inline]
                fn eq(&self, other: &KeyRange) -> bool {
                    self.start == other.start && self.end == other.end
                }
            }
            impl ::prost::Message for KeyRange {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    if self.start != b"" as &[u8] {
                            ::prost::encoding::bytes::encode(1u32, &self.start, buf);
                        }
                    if let ::core::option::Option::Some(ref value) = self.end {
                            ::prost::encoding::bytes::encode(2u32, value, buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "KeyRange";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.start;
                            ::prost::encoding::bytes::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "start"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.end;
                            ::prost::encoding::bytes::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "end"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                            if self.start != b"" as &[u8] {
                                    ::prost::encoding::bytes::encoded_len(1u32, &self.start)
                                } else { 0 } +
                        self.end.as_ref().map_or(0,
                            |value| ::prost::encoding::bytes::encoded_len(2u32, value))
                }
                fn clear(&mut self) {
                    self.start.clear();
                    self.end = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for KeyRange {
                fn default() -> Self {
                    KeyRange {
                        start: ::core::default::Default::default(),
                        end: ::core::option::Option::None,
                    }
                }
            }
            impl ::core::fmt::Debug for KeyRange {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("KeyRange");
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.start)
                                };
                            builder.field("start", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    struct ScalarWrapper<'a>(&'a ::core::option::Option<::prost::alloc::vec::Vec<u8>>);
                                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                        fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                            -> ::core::fmt::Result {
                                            fn Inner<T>(v: T) -> T { v }
                                            ::core::fmt::Debug::fmt(&self.0.as_ref().map(Inner), f)
                                        }
                                    }
                                    ScalarWrapper(&self.end)
                                };
                            builder.field("end", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(dead_code)]
            impl KeyRange {
                #[doc =
                "Returns the value of `end`, or the default value if `end` is unset."]
                pub fn end(&self) -> &[u8] {
                    match self.end {
                        ::core::option::Option::Some(ref val) => &val[..],
                        ::core::option::Option::None => b"" as &[u8],
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct KvPair {
                #[prost(uint64, tag = "1")]
                pub key: u64,
                #[prost(bytes = "vec", tag = "2")]
                pub value: ::prost::alloc::vec::Vec<u8>,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for KvPair {
                #[inline]
                fn clone(&self) -> KvPair {
                    KvPair {
                        key: ::core::clone::Clone::clone(&self.key),
                        value: ::core::clone::Clone::clone(&self.value),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for KvPair { }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for KvPair {
                #[inline]
                fn eq(&self, other: &KvPair) -> bool {
                    self.key == other.key && self.value == other.value
                }
            }
            impl ::prost::Message for KvPair {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    if self.key != 0u64 {
                            ::prost::encoding::uint64::encode(1u32, &self.key, buf);
                        }
                    if self.value != b"" as &[u8] {
                            ::prost::encoding::bytes::encode(2u32, &self.value, buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "KvPair";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.key;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "key"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "value"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                            if self.key != 0u64 {
                                    ::prost::encoding::uint64::encoded_len(1u32, &self.key)
                                } else { 0 } +
                        if self.value != b"" as &[u8] {
                                ::prost::encoding::bytes::encoded_len(2u32, &self.value)
                            } else { 0 }
                }
                fn clear(&mut self) { self.key = 0u64; self.value.clear(); }
            }
            impl ::core::default::Default for KvPair {
                fn default() -> Self {
                    KvPair {
                        key: 0u64,
                        value: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for KvPair {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("KvPair");
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.key)
                                };
                            builder.field("key", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.value)
                                };
                            builder.field("value", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct BaseKvGetRequest {
                #[prost(message, optional, tag = "1")]
                pub key_range: ::core::option::Option<KeyRange>,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for BaseKvGetRequest {
                #[inline]
                fn clone(&self) -> BaseKvGetRequest {
                    BaseKvGetRequest {
                        key_range: ::core::clone::Clone::clone(&self.key_range),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BaseKvGetRequest { }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for BaseKvGetRequest {
                #[inline]
                fn eq(&self, other: &BaseKvGetRequest) -> bool {
                    self.key_range == other.key_range
                }
            }
            impl ::prost::Message for BaseKvGetRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    if let Some(ref msg) = self.key_range {
                            ::prost::encoding::message::encode(1u32, msg, buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "BaseKvGetRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.key_range;
                            ::prost::encoding::message::merge(wire_type,
                                    value.get_or_insert_with(::core::default::Default::default),
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "key_range"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                        self.key_range.as_ref().map_or(0,
                            |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                }
                fn clear(&mut self) {
                    self.key_range = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for BaseKvGetRequest {
                fn default() -> Self {
                    BaseKvGetRequest {
                        key_range: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for BaseKvGetRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("BaseKvGetRequest");
                    let builder =
                        {
                            let wrapper = &self.key_range;
                            builder.field("key_range", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct BaseKvGetResponse {
                #[prost(message, repeated, tag = "1")]
                pub kvs: ::prost::alloc::vec::Vec<KvPair>,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for BaseKvGetResponse {
                #[inline]
                fn clone(&self) -> BaseKvGetResponse {
                    BaseKvGetResponse {
                        kvs: ::core::clone::Clone::clone(&self.kvs),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BaseKvGetResponse { }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for BaseKvGetResponse {
                #[inline]
                fn eq(&self, other: &BaseKvGetResponse) -> bool {
                    self.kvs == other.kvs
                }
            }
            impl ::prost::Message for BaseKvGetResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    for msg in &self.kvs {
                        ::prost::encoding::message::encode(1u32, msg, buf);
                    }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "BaseKvGetResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.kvs;
                            ::prost::encoding::message::merge_repeated(wire_type, value,
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "kvs"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                        ::prost::encoding::message::encoded_len_repeated(1u32,
                            &self.kvs)
                }
                fn clear(&mut self) { self.kvs.clear(); }
            }
            impl ::core::default::Default for BaseKvGetResponse {
                fn default() -> Self {
                    BaseKvGetResponse {
                        kvs: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for BaseKvGetResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("BaseKvGetResponse");
                    let builder =
                        { let wrapper = &self.kvs; builder.field("kvs", &wrapper) };
                    ;
                    builder.finish()
                }
            }
        }
        pub mod raft {
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct VoteRequest {
                #[prost(uint64, tag = "1")]
                pub term: u64,
                #[prost(uint64, tag = "2")]
                pub candidate_id: u64,
                #[prost(uint64, tag = "3")]
                pub last_log_index: u64,
                #[prost(uint64, tag = "4")]
                pub last_log_term: u64,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for VoteRequest {
                #[inline]
                fn clone(&self) -> VoteRequest {
                    VoteRequest {
                        term: ::core::clone::Clone::clone(&self.term),
                        candidate_id: ::core::clone::Clone::clone(&self.candidate_id),
                        last_log_index: ::core::clone::Clone::clone(&self.last_log_index),
                        last_log_term: ::core::clone::Clone::clone(&self.last_log_term),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VoteRequest { }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for VoteRequest {
                #[inline]
                fn eq(&self, other: &VoteRequest) -> bool {
                    self.term == other.term &&
                                self.candidate_id == other.candidate_id &&
                            self.last_log_index == other.last_log_index &&
                        self.last_log_term == other.last_log_term
                }
            }
            impl ::prost::Message for VoteRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    if self.term != 0u64 {
                            ::prost::encoding::uint64::encode(1u32, &self.term, buf);
                        }
                    if self.candidate_id != 0u64 {
                            ::prost::encoding::uint64::encode(2u32, &self.candidate_id,
                                buf);
                        }
                    if self.last_log_index != 0u64 {
                            ::prost::encoding::uint64::encode(3u32,
                                &self.last_log_index, buf);
                        }
                    if self.last_log_term != 0u64 {
                            ::prost::encoding::uint64::encode(4u32, &self.last_log_term,
                                buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "VoteRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.term;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "term"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.candidate_id;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "candidate_id"); error })
                        }
                        3u32 => {
                            let mut value = &mut self.last_log_index;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "last_log_index"); error })
                        }
                        4u32 => {
                            let mut value = &mut self.last_log_term;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "last_log_term"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                                    if self.term != 0u64 {
                                            ::prost::encoding::uint64::encoded_len(1u32, &self.term)
                                        } else { 0 } +
                                if self.candidate_id != 0u64 {
                                        ::prost::encoding::uint64::encoded_len(2u32,
                                            &self.candidate_id)
                                    } else { 0 } +
                            if self.last_log_index != 0u64 {
                                    ::prost::encoding::uint64::encoded_len(3u32,
                                        &self.last_log_index)
                                } else { 0 } +
                        if self.last_log_term != 0u64 {
                                ::prost::encoding::uint64::encoded_len(4u32,
                                    &self.last_log_term)
                            } else { 0 }
                }
                fn clear(&mut self) {
                    self.term = 0u64;
                    self.candidate_id = 0u64;
                    self.last_log_index = 0u64;
                    self.last_log_term = 0u64;
                }
            }
            impl ::core::default::Default for VoteRequest {
                fn default() -> Self {
                    VoteRequest {
                        term: 0u64,
                        candidate_id: 0u64,
                        last_log_index: 0u64,
                        last_log_term: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for VoteRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("VoteRequest");
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.term)
                                };
                            builder.field("term", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.candidate_id)
                                };
                            builder.field("candidate_id", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.last_log_index)
                                };
                            builder.field("last_log_index", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.last_log_term)
                                };
                            builder.field("last_log_term", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct VoteResponse {
                #[prost(uint64, tag = "1")]
                pub term: u64,
                #[prost(bool, tag = "2")]
                pub vote_granted: bool,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for VoteResponse {
                #[inline]
                fn clone(&self) -> VoteResponse {
                    VoteResponse {
                        term: ::core::clone::Clone::clone(&self.term),
                        vote_granted: ::core::clone::Clone::clone(&self.vote_granted),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VoteResponse { }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for VoteResponse {
                #[inline]
                fn eq(&self, other: &VoteResponse) -> bool {
                    self.term == other.term &&
                        self.vote_granted == other.vote_granted
                }
            }
            impl ::prost::Message for VoteResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    if self.term != 0u64 {
                            ::prost::encoding::uint64::encode(1u32, &self.term, buf);
                        }
                    if self.vote_granted != false {
                            ::prost::encoding::bool::encode(2u32, &self.vote_granted,
                                buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "VoteResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.term;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "term"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.vote_granted;
                            ::prost::encoding::bool::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "vote_granted"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                            if self.term != 0u64 {
                                    ::prost::encoding::uint64::encoded_len(1u32, &self.term)
                                } else { 0 } +
                        if self.vote_granted != false {
                                ::prost::encoding::bool::encoded_len(2u32,
                                    &self.vote_granted)
                            } else { 0 }
                }
                fn clear(&mut self) {
                    self.term = 0u64;
                    self.vote_granted = false;
                }
            }
            impl ::core::default::Default for VoteResponse {
                fn default() -> Self {
                    VoteResponse { term: 0u64, vote_granted: false }
                }
            }
            impl ::core::fmt::Debug for VoteResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("VoteResponse");
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.term)
                                };
                            builder.field("term", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.vote_granted)
                                };
                            builder.field("vote_granted", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct LogEntryPayload {}
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for LogEntryPayload {
                #[inline]
                fn clone(&self) -> LogEntryPayload { LogEntryPayload {} }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for LogEntryPayload { }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for LogEntryPayload {
                #[inline]
                fn eq(&self, other: &LogEntryPayload) -> bool { true }
            }
            impl ::prost::Message for LogEntryPayload {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {}
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    match tag {
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize { 0 }
                fn clear(&mut self) {}
            }
            impl ::core::default::Default for LogEntryPayload {
                fn default() -> Self { LogEntryPayload {} }
            }
            impl ::core::fmt::Debug for LogEntryPayload {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("LogEntryPayload");
                    builder.finish()
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct LogEntry {
                #[prost(uint64, tag = "1")]
                pub term: u64,
                #[prost(uint64, tag = "2")]
                pub index: u64,
                #[prost(oneof = "log_entry::Payload", tags = "3, 4, 5, 6")]
                pub payload: ::core::option::Option<log_entry::Payload>,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for LogEntry {
                #[inline]
                fn clone(&self) -> LogEntry {
                    LogEntry {
                        term: ::core::clone::Clone::clone(&self.term),
                        index: ::core::clone::Clone::clone(&self.index),
                        payload: ::core::clone::Clone::clone(&self.payload),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for LogEntry { }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for LogEntry {
                #[inline]
                fn eq(&self, other: &LogEntry) -> bool {
                    self.term == other.term && self.index == other.index &&
                        self.payload == other.payload
                }
            }
            impl ::prost::Message for LogEntry {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    if self.term != 0u64 {
                            ::prost::encoding::uint64::encode(1u32, &self.term, buf);
                        }
                    if self.index != 0u64 {
                            ::prost::encoding::uint64::encode(2u32, &self.index, buf);
                        }
                    if let Some(ref oneof) = self.payload { oneof.encode(buf) }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "LogEntry";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.term;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "term"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.index;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "index"); error })
                        }
                        3u32 | 4u32 | 5u32 | 6u32 => {
                            let mut value = &mut self.payload;
                            log_entry::Payload::merge(value, tag, wire_type, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "payload"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                                if self.term != 0u64 {
                                        ::prost::encoding::uint64::encoded_len(1u32, &self.term)
                                    } else { 0 } +
                            if self.index != 0u64 {
                                    ::prost::encoding::uint64::encoded_len(2u32, &self.index)
                                } else { 0 } +
                        self.payload.as_ref().map_or(0,
                            log_entry::Payload::encoded_len)
                }
                fn clear(&mut self) {
                    self.term = 0u64;
                    self.index = 0u64;
                    self.payload = ::core::option::Option::None;
                }
            }
            impl ::core::default::Default for LogEntry {
                fn default() -> Self {
                    LogEntry {
                        term: 0u64,
                        index: 0u64,
                        payload: ::core::default::Default::default(),
                    }
                }
            }
            impl ::core::fmt::Debug for LogEntry {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("LogEntry");
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.term)
                                };
                            builder.field("term", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.index)
                                };
                            builder.field("index", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.payload;
                            builder.field("payload", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            /// Nested message and enum types in `LogEntry`.
            pub mod log_entry {
                #[allow(clippy :: derive_partial_eq_without_eq)]
                pub struct MembershipConfig {
                    #[prost(uint64, repeated, tag = "1")]
                    pub members: ::prost::alloc::vec::Vec<u64>,
                    #[prost(bool, tag = "2")]
                    pub members_after_consensus_exist: bool,
                    #[prost(uint64, repeated, tag = "3")]
                    pub members_after_consensus: ::prost::alloc::vec::Vec<u64>,
                }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for MembershipConfig {
                    #[inline]
                    fn clone(&self) -> MembershipConfig {
                        MembershipConfig {
                            members: ::core::clone::Clone::clone(&self.members),
                            members_after_consensus_exist: ::core::clone::Clone::clone(&self.members_after_consensus_exist),
                            members_after_consensus: ::core::clone::Clone::clone(&self.members_after_consensus),
                        }
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for MembershipConfig
                    {
                }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for MembershipConfig {
                    #[inline]
                    fn eq(&self, other: &MembershipConfig) -> bool {
                        self.members == other.members &&
                                self.members_after_consensus_exist ==
                                    other.members_after_consensus_exist &&
                            self.members_after_consensus ==
                                other.members_after_consensus
                    }
                }
                impl ::prost::Message for MembershipConfig {
                    #[allow(unused_variables)]
                    fn encode_raw<B>(&self, buf: &mut B) where
                        B: ::prost::bytes::BufMut {
                        ::prost::encoding::uint64::encode_packed(1u32,
                            &self.members, buf);
                        if self.members_after_consensus_exist != false {
                                ::prost::encoding::bool::encode(2u32,
                                    &self.members_after_consensus_exist, buf);
                            }
                        ::prost::encoding::uint64::encode_packed(3u32,
                            &self.members_after_consensus, buf);
                    }
                    #[allow(unused_variables)]
                    fn merge_field<B>(&mut self, tag: u32,
                        wire_type: ::prost::encoding::WireType, buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> where
                        B: ::prost::bytes::Buf {
                        const STRUCT_NAME: &'static str = "MembershipConfig";
                        match tag {
                            1u32 => {
                                let mut value = &mut self.members;
                                ::prost::encoding::uint64::merge_repeated(wire_type, value,
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "members"); error })
                            }
                            2u32 => {
                                let mut value = &mut self.members_after_consensus_exist;
                                ::prost::encoding::bool::merge(wire_type, value, buf,
                                        ctx).map_err(|mut error|
                                        {
                                            error.push(STRUCT_NAME, "members_after_consensus_exist");
                                            error
                                        })
                            }
                            3u32 => {
                                let mut value = &mut self.members_after_consensus;
                                ::prost::encoding::uint64::merge_repeated(wire_type, value,
                                        buf,
                                        ctx).map_err(|mut error|
                                        {
                                            error.push(STRUCT_NAME, "members_after_consensus");
                                            error
                                        })
                            }
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize {
                        0 +
                                    ::prost::encoding::uint64::encoded_len_packed(1u32,
                                        &self.members) +
                                if self.members_after_consensus_exist != false {
                                        ::prost::encoding::bool::encoded_len(2u32,
                                            &self.members_after_consensus_exist)
                                    } else { 0 } +
                            ::prost::encoding::uint64::encoded_len_packed(3u32,
                                &self.members_after_consensus)
                    }
                    fn clear(&mut self) {
                        self.members.clear();
                        self.members_after_consensus_exist = false;
                        self.members_after_consensus.clear();
                    }
                }
                impl ::core::default::Default for MembershipConfig {
                    fn default() -> Self {
                        MembershipConfig {
                            members: ::prost::alloc::vec::Vec::new(),
                            members_after_consensus_exist: false,
                            members_after_consensus: ::prost::alloc::vec::Vec::new(),
                        }
                    }
                }
                impl ::core::fmt::Debug for MembershipConfig {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("MembershipConfig");
                        let builder =
                            {
                                let wrapper =
                                    {
                                        struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                                        impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                let mut vec_builder = f.debug_list();
                                                for v in self.0 {
                                                    fn Inner<T>(v: T) -> T { v }
                                                    vec_builder.entry(&Inner(v));
                                                }
                                                vec_builder.finish()
                                            }
                                        }
                                        ScalarWrapper(&self.members)
                                    };
                                builder.field("members", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper =
                                    {
                                        fn ScalarWrapper<T>(v: T) -> T { v }
                                        ScalarWrapper(&self.members_after_consensus_exist)
                                    };
                                builder.field("members_after_consensus_exist", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper =
                                    {
                                        struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                                        impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                                            fn fmt(&self, f: &mut ::core::fmt::Formatter)
                                                -> ::core::fmt::Result {
                                                let mut vec_builder = f.debug_list();
                                                for v in self.0 {
                                                    fn Inner<T>(v: T) -> T { v }
                                                    vec_builder.entry(&Inner(v));
                                                }
                                                vec_builder.finish()
                                            }
                                        }
                                        ScalarWrapper(&self.members_after_consensus)
                                    };
                                builder.field("members_after_consensus", &wrapper)
                            };
                        ;
                        builder.finish()
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                pub struct EntrySnapshotPointer {
                    #[prost(string, tag = "1")]
                    pub id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "2")]
                    pub membership: ::core::option::Option<MembershipConfig>,
                }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for EntrySnapshotPointer {
                    #[inline]
                    fn clone(&self) -> EntrySnapshotPointer {
                        EntrySnapshotPointer {
                            id: ::core::clone::Clone::clone(&self.id),
                            membership: ::core::clone::Clone::clone(&self.membership),
                        }
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for
                    EntrySnapshotPointer {
                }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for EntrySnapshotPointer {
                    #[inline]
                    fn eq(&self, other: &EntrySnapshotPointer) -> bool {
                        self.id == other.id && self.membership == other.membership
                    }
                }
                impl ::prost::Message for EntrySnapshotPointer {
                    #[allow(unused_variables)]
                    fn encode_raw<B>(&self, buf: &mut B) where
                        B: ::prost::bytes::BufMut {
                        if self.id != "" {
                                ::prost::encoding::string::encode(1u32, &self.id, buf);
                            }
                        if let Some(ref msg) = self.membership {
                                ::prost::encoding::message::encode(2u32, msg, buf);
                            }
                    }
                    #[allow(unused_variables)]
                    fn merge_field<B>(&mut self, tag: u32,
                        wire_type: ::prost::encoding::WireType, buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> where
                        B: ::prost::bytes::Buf {
                        const STRUCT_NAME: &'static str = "EntrySnapshotPointer";
                        match tag {
                            1u32 => {
                                let mut value = &mut self.id;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "id"); error })
                            }
                            2u32 => {
                                let mut value = &mut self.membership;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "membership"); error })
                            }
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize {
                        0 +
                                if self.id != "" {
                                        ::prost::encoding::string::encoded_len(1u32, &self.id)
                                    } else { 0 } +
                            self.membership.as_ref().map_or(0,
                                |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                    }
                    fn clear(&mut self) {
                        self.id.clear();
                        self.membership = ::core::option::Option::None;
                    }
                }
                impl ::core::default::Default for EntrySnapshotPointer {
                    fn default() -> Self {
                        EntrySnapshotPointer {
                            id: ::prost::alloc::string::String::new(),
                            membership: ::core::default::Default::default(),
                        }
                    }
                }
                impl ::core::fmt::Debug for EntrySnapshotPointer {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("EntrySnapshotPointer");
                        let builder =
                            {
                                let wrapper =
                                    {
                                        fn ScalarWrapper<T>(v: T) -> T { v }
                                        ScalarWrapper(&self.id)
                                    };
                                builder.field("id", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper = &self.membership;
                                builder.field("membership", &wrapper)
                            };
                        ;
                        builder.finish()
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                pub struct EntryConfigChange {
                    #[prost(message, optional, tag = "1")]
                    pub membership: ::core::option::Option<MembershipConfig>,
                }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for EntryConfigChange {
                    #[inline]
                    fn clone(&self) -> EntryConfigChange {
                        EntryConfigChange {
                            membership: ::core::clone::Clone::clone(&self.membership),
                        }
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for EntryConfigChange
                    {
                }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for EntryConfigChange {
                    #[inline]
                    fn eq(&self, other: &EntryConfigChange) -> bool {
                        self.membership == other.membership
                    }
                }
                impl ::prost::Message for EntryConfigChange {
                    #[allow(unused_variables)]
                    fn encode_raw<B>(&self, buf: &mut B) where
                        B: ::prost::bytes::BufMut {
                        if let Some(ref msg) = self.membership {
                                ::prost::encoding::message::encode(1u32, msg, buf);
                            }
                    }
                    #[allow(unused_variables)]
                    fn merge_field<B>(&mut self, tag: u32,
                        wire_type: ::prost::encoding::WireType, buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> where
                        B: ::prost::bytes::Buf {
                        const STRUCT_NAME: &'static str = "EntryConfigChange";
                        match tag {
                            1u32 => {
                                let mut value = &mut self.membership;
                                ::prost::encoding::message::merge(wire_type,
                                        value.get_or_insert_with(::core::default::Default::default),
                                        buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "membership"); error })
                            }
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize {
                        0 +
                            self.membership.as_ref().map_or(0,
                                |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                    }
                    fn clear(&mut self) {
                        self.membership = ::core::option::Option::None;
                    }
                }
                impl ::core::default::Default for EntryConfigChange {
                    fn default() -> Self {
                        EntryConfigChange {
                            membership: ::core::default::Default::default(),
                        }
                    }
                }
                impl ::core::fmt::Debug for EntryConfigChange {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("EntryConfigChange");
                        let builder =
                            {
                                let wrapper = &self.membership;
                                builder.field("membership", &wrapper)
                            };
                        ;
                        builder.finish()
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                pub struct EntryNormal {
                    #[prost(string, tag = "1")]
                    pub client: ::prost::alloc::string::String,
                    #[prost(uint64, tag = "2")]
                    pub serial: u64,
                    #[prost(string, tag = "3")]
                    pub status: ::prost::alloc::string::String,
                }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for EntryNormal {
                    #[inline]
                    fn clone(&self) -> EntryNormal {
                        EntryNormal {
                            client: ::core::clone::Clone::clone(&self.client),
                            serial: ::core::clone::Clone::clone(&self.serial),
                            status: ::core::clone::Clone::clone(&self.status),
                        }
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for EntryNormal { }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for EntryNormal {
                    #[inline]
                    fn eq(&self, other: &EntryNormal) -> bool {
                        self.client == other.client && self.serial == other.serial
                            && self.status == other.status
                    }
                }
                impl ::prost::Message for EntryNormal {
                    #[allow(unused_variables)]
                    fn encode_raw<B>(&self, buf: &mut B) where
                        B: ::prost::bytes::BufMut {
                        if self.client != "" {
                                ::prost::encoding::string::encode(1u32, &self.client, buf);
                            }
                        if self.serial != 0u64 {
                                ::prost::encoding::uint64::encode(2u32, &self.serial, buf);
                            }
                        if self.status != "" {
                                ::prost::encoding::string::encode(3u32, &self.status, buf);
                            }
                    }
                    #[allow(unused_variables)]
                    fn merge_field<B>(&mut self, tag: u32,
                        wire_type: ::prost::encoding::WireType, buf: &mut B,
                        ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> where
                        B: ::prost::bytes::Buf {
                        const STRUCT_NAME: &'static str = "EntryNormal";
                        match tag {
                            1u32 => {
                                let mut value = &mut self.client;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "client"); error })
                            }
                            2u32 => {
                                let mut value = &mut self.serial;
                                ::prost::encoding::uint64::merge(wire_type, value, buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "serial"); error })
                            }
                            3u32 => {
                                let mut value = &mut self.status;
                                ::prost::encoding::string::merge(wire_type, value, buf,
                                        ctx).map_err(|mut error|
                                        { error.push(STRUCT_NAME, "status"); error })
                            }
                            _ =>
                                ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                        }
                    }
                    #[inline]
                    fn encoded_len(&self) -> usize {
                        0 +
                                    if self.client != "" {
                                            ::prost::encoding::string::encoded_len(1u32, &self.client)
                                        } else { 0 } +
                                if self.serial != 0u64 {
                                        ::prost::encoding::uint64::encoded_len(2u32, &self.serial)
                                    } else { 0 } +
                            if self.status != "" {
                                    ::prost::encoding::string::encoded_len(3u32, &self.status)
                                } else { 0 }
                    }
                    fn clear(&mut self) {
                        self.client.clear();
                        self.serial = 0u64;
                        self.status.clear();
                    }
                }
                impl ::core::default::Default for EntryNormal {
                    fn default() -> Self {
                        EntryNormal {
                            client: ::prost::alloc::string::String::new(),
                            serial: 0u64,
                            status: ::prost::alloc::string::String::new(),
                        }
                    }
                }
                impl ::core::fmt::Debug for EntryNormal {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        let mut builder = f.debug_struct("EntryNormal");
                        let builder =
                            {
                                let wrapper =
                                    {
                                        fn ScalarWrapper<T>(v: T) -> T { v }
                                        ScalarWrapper(&self.client)
                                    };
                                builder.field("client", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper =
                                    {
                                        fn ScalarWrapper<T>(v: T) -> T { v }
                                        ScalarWrapper(&self.serial)
                                    };
                                builder.field("serial", &wrapper)
                            };
                        ;
                        let builder =
                            {
                                let wrapper =
                                    {
                                        fn ScalarWrapper<T>(v: T) -> T { v }
                                        ScalarWrapper(&self.status)
                                    };
                                builder.field("status", &wrapper)
                            };
                        ;
                        builder.finish()
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                pub enum Payload {

                    #[prost(bool, tag = "3")]
                    Blank(bool),

                    #[prost(message, tag = "4")]
                    Normal(EntryNormal),

                    #[prost(message, tag = "5")]
                    ConfigChange(EntryConfigChange),

                    #[prost(message, tag = "6")]
                    SnapshotPointer(EntrySnapshotPointer),
                }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::clone::Clone for Payload {
                    #[inline]
                    fn clone(&self) -> Payload {
                        match self {
                            Payload::Blank(__self_0) =>
                                Payload::Blank(::core::clone::Clone::clone(__self_0)),
                            Payload::Normal(__self_0) =>
                                Payload::Normal(::core::clone::Clone::clone(__self_0)),
                            Payload::ConfigChange(__self_0) =>
                                Payload::ConfigChange(::core::clone::Clone::clone(__self_0)),
                            Payload::SnapshotPointer(__self_0) =>
                                Payload::SnapshotPointer(::core::clone::Clone::clone(__self_0)),
                        }
                    }
                }
                #[allow(clippy :: derive_partial_eq_without_eq)]
                #[automatically_derived]
                impl ::core::marker::StructuralPartialEq for Payload { }
                #[automatically_derived]
                #[allow(clippy :: derive_partial_eq_without_eq)]
                impl ::core::cmp::PartialEq for Payload {
                    #[inline]
                    fn eq(&self, other: &Payload) -> bool {
                        let __self_tag =
                            ::core::intrinsics::discriminant_value(self);
                        let __arg1_tag =
                            ::core::intrinsics::discriminant_value(other);
                        __self_tag == __arg1_tag &&
                            match (self, other) {
                                (Payload::Blank(__self_0), Payload::Blank(__arg1_0)) =>
                                    *__self_0 == *__arg1_0,
                                (Payload::Normal(__self_0), Payload::Normal(__arg1_0)) =>
                                    *__self_0 == *__arg1_0,
                                (Payload::ConfigChange(__self_0),
                                    Payload::ConfigChange(__arg1_0)) => *__self_0 == *__arg1_0,
                                (Payload::SnapshotPointer(__self_0),
                                    Payload::SnapshotPointer(__arg1_0)) =>
                                    *__self_0 == *__arg1_0,
                                _ => unsafe { ::core::intrinsics::unreachable() }
                            }
                    }
                }
                impl Payload {
                    #[doc = r" Encodes the message to a buffer."]
                    pub fn encode<B>(&self, buf: &mut B) where
                        B: ::prost::bytes::BufMut {
                        match *self {
                            Payload::Blank(ref value) => {
                                ::prost::encoding::bool::encode(3u32, &*value, buf);
                            }
                            Payload::Normal(ref value) => {
                                ::prost::encoding::message::encode(4u32, &*value, buf);
                            }
                            Payload::ConfigChange(ref value) => {
                                ::prost::encoding::message::encode(5u32, &*value, buf);
                            }
                            Payload::SnapshotPointer(ref value) => {
                                ::prost::encoding::message::encode(6u32, &*value, buf);
                            }
                        }
                    }
                    #[doc =
                    r" Decodes an instance of the message from a buffer, and merges it into self."]
                    pub fn merge<B>(field: &mut ::core::option::Option<Payload>,
                        tag: u32, wire_type: ::prost::encoding::WireType,
                        buf: &mut B, ctx: ::prost::encoding::DecodeContext)
                        -> ::core::result::Result<(), ::prost::DecodeError> where
                        B: ::prost::bytes::Buf {
                        match tag {
                            3u32 => {
                                match field {
                                    ::core::option::Option::Some(Payload::Blank(ref mut value))
                                        => {
                                        ::prost::encoding::bool::merge(wire_type, value, buf, ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::bool::merge(wire_type, value, buf,
                                                ctx).map(|_|
                                                *field =
                                                    ::core::option::Option::Some(Payload::Blank(owned_value)))
                                    }
                                }
                            }
                            4u32 => {
                                match field {
                                    ::core::option::Option::Some(Payload::Normal(ref mut value))
                                        => {
                                        ::prost::encoding::message::merge(wire_type, value, buf,
                                            ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(wire_type, value, buf,
                                                ctx).map(|_|
                                                *field =
                                                    ::core::option::Option::Some(Payload::Normal(owned_value)))
                                    }
                                }
                            }
                            5u32 => {
                                match field {
                                    ::core::option::Option::Some(Payload::ConfigChange(ref mut value))
                                        => {
                                        ::prost::encoding::message::merge(wire_type, value, buf,
                                            ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(wire_type, value, buf,
                                                ctx).map(|_|
                                                *field =
                                                    ::core::option::Option::Some(Payload::ConfigChange(owned_value)))
                                    }
                                }
                            }
                            6u32 => {
                                match field {
                                    ::core::option::Option::Some(Payload::SnapshotPointer(ref mut value))
                                        => {
                                        ::prost::encoding::message::merge(wire_type, value, buf,
                                            ctx)
                                    }
                                    _ => {
                                        let mut owned_value = ::core::default::Default::default();
                                        let value = &mut owned_value;
                                        ::prost::encoding::message::merge(wire_type, value, buf,
                                                ctx).map(|_|
                                                *field =
                                                    ::core::option::Option::Some(Payload::SnapshotPointer(owned_value)))
                                    }
                                }
                            }
                            _ =>
                                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(&["internal error: entered unreachable code: "],
                                        &[::core::fmt::ArgumentV1::new_display(&::core::fmt::Arguments::new_v1(&["invalid Payload tag: "],
                                                                &[::core::fmt::ArgumentV1::new_display(&tag)]))])),
                        }
                    }
                    #[doc =
                    r" Returns the encoded length of the message without a length delimiter."]
                    #[inline]
                    pub fn encoded_len(&self) -> usize {
                        match *self {
                            Payload::Blank(ref value) =>
                                ::prost::encoding::bool::encoded_len(3u32, &*value),
                            Payload::Normal(ref value) =>
                                ::prost::encoding::message::encoded_len(4u32, &*value),
                            Payload::ConfigChange(ref value) =>
                                ::prost::encoding::message::encoded_len(5u32, &*value),
                            Payload::SnapshotPointer(ref value) =>
                                ::prost::encoding::message::encoded_len(6u32, &*value),
                        }
                    }
                }
                impl ::core::fmt::Debug for Payload {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter)
                        -> ::core::fmt::Result {
                        match *self {
                            Payload::Blank(ref value) => {
                                let wrapper =
                                    {
                                        fn ScalarWrapper<T>(v: T) -> T { v }
                                        ScalarWrapper(&*value)
                                    };
                                f.debug_tuple("Blank").field(&wrapper).finish()
                            }
                            Payload::Normal(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("Normal").field(&wrapper).finish()
                            }
                            Payload::ConfigChange(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("ConfigChange").field(&wrapper).finish()
                            }
                            Payload::SnapshotPointer(ref value) => {
                                let wrapper = &*value;
                                f.debug_tuple("SnapshotPointer").field(&wrapper).finish()
                            }
                        }
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct AppendEntriesRequest {
                #[prost(uint64, tag = "1")]
                pub term: u64,
                #[prost(uint64, tag = "2")]
                pub leader_id: u64,
                #[prost(uint64, tag = "3")]
                pub prev_log_index: u64,
                #[prost(uint64, tag = "4")]
                pub prev_log_term: u64,
                #[prost(message, repeated, tag = "5")]
                pub entries: ::prost::alloc::vec::Vec<LogEntry>,
                #[prost(uint64, tag = "6")]
                pub leader_commit: u64,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for AppendEntriesRequest {
                #[inline]
                fn clone(&self) -> AppendEntriesRequest {
                    AppendEntriesRequest {
                        term: ::core::clone::Clone::clone(&self.term),
                        leader_id: ::core::clone::Clone::clone(&self.leader_id),
                        prev_log_index: ::core::clone::Clone::clone(&self.prev_log_index),
                        prev_log_term: ::core::clone::Clone::clone(&self.prev_log_term),
                        entries: ::core::clone::Clone::clone(&self.entries),
                        leader_commit: ::core::clone::Clone::clone(&self.leader_commit),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AppendEntriesRequest
                {
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for AppendEntriesRequest {
                #[inline]
                fn eq(&self, other: &AppendEntriesRequest) -> bool {
                    self.term == other.term && self.leader_id == other.leader_id
                                    && self.prev_log_index == other.prev_log_index &&
                                self.prev_log_term == other.prev_log_term &&
                            self.entries == other.entries &&
                        self.leader_commit == other.leader_commit
                }
            }
            impl ::prost::Message for AppendEntriesRequest {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    if self.term != 0u64 {
                            ::prost::encoding::uint64::encode(1u32, &self.term, buf);
                        }
                    if self.leader_id != 0u64 {
                            ::prost::encoding::uint64::encode(2u32, &self.leader_id,
                                buf);
                        }
                    if self.prev_log_index != 0u64 {
                            ::prost::encoding::uint64::encode(3u32,
                                &self.prev_log_index, buf);
                        }
                    if self.prev_log_term != 0u64 {
                            ::prost::encoding::uint64::encode(4u32, &self.prev_log_term,
                                buf);
                        }
                    for msg in &self.entries {
                        ::prost::encoding::message::encode(5u32, msg, buf);
                    }
                    if self.leader_commit != 0u64 {
                            ::prost::encoding::uint64::encode(6u32, &self.leader_commit,
                                buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "AppendEntriesRequest";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.term;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "term"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.leader_id;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "leader_id"); error })
                        }
                        3u32 => {
                            let mut value = &mut self.prev_log_index;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "prev_log_index"); error })
                        }
                        4u32 => {
                            let mut value = &mut self.prev_log_term;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "prev_log_term"); error })
                        }
                        5u32 => {
                            let mut value = &mut self.entries;
                            ::prost::encoding::message::merge_repeated(wire_type, value,
                                    buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "entries"); error })
                        }
                        6u32 => {
                            let mut value = &mut self.leader_commit;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "leader_commit"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                                            if self.term != 0u64 {
                                                    ::prost::encoding::uint64::encoded_len(1u32, &self.term)
                                                } else { 0 } +
                                        if self.leader_id != 0u64 {
                                                ::prost::encoding::uint64::encoded_len(2u32,
                                                    &self.leader_id)
                                            } else { 0 } +
                                    if self.prev_log_index != 0u64 {
                                            ::prost::encoding::uint64::encoded_len(3u32,
                                                &self.prev_log_index)
                                        } else { 0 } +
                                if self.prev_log_term != 0u64 {
                                        ::prost::encoding::uint64::encoded_len(4u32,
                                            &self.prev_log_term)
                                    } else { 0 } +
                            ::prost::encoding::message::encoded_len_repeated(5u32,
                                &self.entries) +
                        if self.leader_commit != 0u64 {
                                ::prost::encoding::uint64::encoded_len(6u32,
                                    &self.leader_commit)
                            } else { 0 }
                }
                fn clear(&mut self) {
                    self.term = 0u64;
                    self.leader_id = 0u64;
                    self.prev_log_index = 0u64;
                    self.prev_log_term = 0u64;
                    self.entries.clear();
                    self.leader_commit = 0u64;
                }
            }
            impl ::core::default::Default for AppendEntriesRequest {
                fn default() -> Self {
                    AppendEntriesRequest {
                        term: 0u64,
                        leader_id: 0u64,
                        prev_log_index: 0u64,
                        prev_log_term: 0u64,
                        entries: ::core::default::Default::default(),
                        leader_commit: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for AppendEntriesRequest {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("AppendEntriesRequest");
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.term)
                                };
                            builder.field("term", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.leader_id)
                                };
                            builder.field("leader_id", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.prev_log_index)
                                };
                            builder.field("prev_log_index", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.prev_log_term)
                                };
                            builder.field("prev_log_term", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper = &self.entries;
                            builder.field("entries", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.leader_commit)
                                };
                            builder.field("leader_commit", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            pub struct AppendEntriesResponse {
                #[prost(uint64, tag = "1")]
                pub term: u64,
                #[prost(bool, tag = "2")]
                pub success: bool,
                #[prost(uint64, tag = "3")]
                pub conflict_index: u64,
                #[prost(uint64, tag = "4")]
                pub conflict_term: u64,
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::clone::Clone for AppendEntriesResponse {
                #[inline]
                fn clone(&self) -> AppendEntriesResponse {
                    AppendEntriesResponse {
                        term: ::core::clone::Clone::clone(&self.term),
                        success: ::core::clone::Clone::clone(&self.success),
                        conflict_index: ::core::clone::Clone::clone(&self.conflict_index),
                        conflict_term: ::core::clone::Clone::clone(&self.conflict_term),
                    }
                }
            }
            #[allow(clippy :: derive_partial_eq_without_eq)]
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AppendEntriesResponse
                {
            }
            #[automatically_derived]
            #[allow(clippy :: derive_partial_eq_without_eq)]
            impl ::core::cmp::PartialEq for AppendEntriesResponse {
                #[inline]
                fn eq(&self, other: &AppendEntriesResponse) -> bool {
                    self.term == other.term && self.success == other.success &&
                            self.conflict_index == other.conflict_index &&
                        self.conflict_term == other.conflict_term
                }
            }
            impl ::prost::Message for AppendEntriesResponse {
                #[allow(unused_variables)]
                fn encode_raw<B>(&self, buf: &mut B) where
                    B: ::prost::bytes::BufMut {
                    if self.term != 0u64 {
                            ::prost::encoding::uint64::encode(1u32, &self.term, buf);
                        }
                    if self.success != false {
                            ::prost::encoding::bool::encode(2u32, &self.success, buf);
                        }
                    if self.conflict_index != 0u64 {
                            ::prost::encoding::uint64::encode(3u32,
                                &self.conflict_index, buf);
                        }
                    if self.conflict_term != 0u64 {
                            ::prost::encoding::uint64::encode(4u32, &self.conflict_term,
                                buf);
                        }
                }
                #[allow(unused_variables)]
                fn merge_field<B>(&mut self, tag: u32,
                    wire_type: ::prost::encoding::WireType, buf: &mut B,
                    ctx: ::prost::encoding::DecodeContext)
                    -> ::core::result::Result<(), ::prost::DecodeError> where
                    B: ::prost::bytes::Buf {
                    const STRUCT_NAME: &'static str = "AppendEntriesResponse";
                    match tag {
                        1u32 => {
                            let mut value = &mut self.term;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "term"); error })
                        }
                        2u32 => {
                            let mut value = &mut self.success;
                            ::prost::encoding::bool::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "success"); error })
                        }
                        3u32 => {
                            let mut value = &mut self.conflict_index;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "conflict_index"); error })
                        }
                        4u32 => {
                            let mut value = &mut self.conflict_term;
                            ::prost::encoding::uint64::merge(wire_type, value, buf,
                                    ctx).map_err(|mut error|
                                    { error.push(STRUCT_NAME, "conflict_term"); error })
                        }
                        _ =>
                            ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                    }
                }
                #[inline]
                fn encoded_len(&self) -> usize {
                    0 +
                                    if self.term != 0u64 {
                                            ::prost::encoding::uint64::encoded_len(1u32, &self.term)
                                        } else { 0 } +
                                if self.success != false {
                                        ::prost::encoding::bool::encoded_len(2u32, &self.success)
                                    } else { 0 } +
                            if self.conflict_index != 0u64 {
                                    ::prost::encoding::uint64::encoded_len(3u32,
                                        &self.conflict_index)
                                } else { 0 } +
                        if self.conflict_term != 0u64 {
                                ::prost::encoding::uint64::encoded_len(4u32,
                                    &self.conflict_term)
                            } else { 0 }
                }
                fn clear(&mut self) {
                    self.term = 0u64;
                    self.success = false;
                    self.conflict_index = 0u64;
                    self.conflict_term = 0u64;
                }
            }
            impl ::core::default::Default for AppendEntriesResponse {
                fn default() -> Self {
                    AppendEntriesResponse {
                        term: 0u64,
                        success: false,
                        conflict_index: 0u64,
                        conflict_term: 0u64,
                    }
                }
            }
            impl ::core::fmt::Debug for AppendEntriesResponse {
                fn fmt(&self, f: &mut ::core::fmt::Formatter)
                    -> ::core::fmt::Result {
                    let mut builder = f.debug_struct("AppendEntriesResponse");
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.term)
                                };
                            builder.field("term", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.success)
                                };
                            builder.field("success", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.conflict_index)
                                };
                            builder.field("conflict_index", &wrapper)
                        };
                    ;
                    let builder =
                        {
                            let wrapper =
                                {
                                    fn ScalarWrapper<T>(v: T) -> T { v }
                                    ScalarWrapper(&self.conflict_term)
                                };
                            builder.field("conflict_term", &wrapper)
                        };
                    ;
                    builder.finish()
                }
            }
        }
    }
}
pub mod result {
    use async_raft::{InitializeError, RaftError};
    use camelpaste::paste;
    use prost::DecodeError;
    use qp2p::{EndpointError, SendError};
    use thiserror::Error;
    use crate::sys::NodeID;
    pub type WSResult<T> = Result<T, WSError>;
    pub enum NotMatchNodeErr { NotRaft(String), }
    #[automatically_derived]
    impl ::core::fmt::Debug for NotMatchNodeErr {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                NotMatchNodeErr::NotRaft(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "NotRaft", &__self_0),
            }
        }
    }
    pub enum WsNetworkLogicErr {
        DecodeError(DecodeError),
        MsgIdNotDispatchable(u32),
        InvaidNodeID(NodeID),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for WsNetworkLogicErr {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                WsNetworkLogicErr::DecodeError(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "DecodeError", &__self_0),
                WsNetworkLogicErr::MsgIdNotDispatchable(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "MsgIdNotDispatchable", &__self_0),
                WsNetworkLogicErr::InvaidNodeID(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "InvaidNodeID", &__self_0),
            }
        }
    }
    pub enum WsNetworkConnErr {
        EndPointError(EndpointError),
        SendError(SendError),
        ConnectionNotEstablished(NodeID),
        RPCTimout(NodeID),
        ConnectionExpired(NodeID),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for WsNetworkConnErr {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                WsNetworkConnErr::EndPointError(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "EndPointError", &__self_0),
                WsNetworkConnErr::SendError(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "SendError", &__self_0),
                WsNetworkConnErr::ConnectionNotEstablished(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "ConnectionNotEstablished", &__self_0),
                WsNetworkConnErr::RPCTimout(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "RPCTimout", &__self_0),
                WsNetworkConnErr::ConnectionExpired(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "ConnectionExpired", &__self_0),
            }
        }
    }
    pub enum WsRaftErr {
        InitializeError(async_raft::error::InitializeError),
        RaftError(RaftError),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for WsRaftErr {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                WsRaftErr::InitializeError(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "InitializeError", &__self_0),
                WsRaftErr::RaftError(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "RaftError", &__self_0),
            }
        }
    }
    pub enum WsSerialErr { BincodeErr(Box<bincode::ErrorKind>), }
    #[automatically_derived]
    impl ::core::fmt::Debug for WsSerialErr {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                WsSerialErr::BincodeErr(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "BincodeErr", &__self_0),
            }
        }
    }
    pub enum WSError {

        #[error("Network logic error: {0:?}")]
        WsNetworkLogicErr(WsNetworkLogicErr),

        #[error("Network connection error: {0:?}")]
        WsNetworkConnErr(WsNetworkConnErr),

        #[error("Raft error: {0:?}")]
        WsRaftErr(WsRaftErr),

        #[error("Serial error: {0:?}")]
        WsSerialErr(WsSerialErr),

        #[error("Not Implemented")]
        NotImplemented,
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for WSError { }
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for WSError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter)
            -> ::core::fmt::Result {

            #[allow(unused_variables, deprecated, clippy ::
            used_underscore_binding)]
            match self {
                WSError::WsNetworkLogicErr(_0) =>
                    __formatter.write_fmt(::core::fmt::Arguments::new_v1(&["Network logic error: "],
                            &[::core::fmt::ArgumentV1::new_debug(&_0)])),
                WSError::WsNetworkConnErr(_0) =>
                    __formatter.write_fmt(::core::fmt::Arguments::new_v1(&["Network connection error: "],
                            &[::core::fmt::ArgumentV1::new_debug(&_0)])),
                WSError::WsRaftErr(_0) =>
                    __formatter.write_fmt(::core::fmt::Arguments::new_v1(&["Raft error: "],
                            &[::core::fmt::ArgumentV1::new_debug(&_0)])),
                WSError::WsSerialErr(_0) =>
                    __formatter.write_fmt(::core::fmt::Arguments::new_v1(&["Serial error: "],
                            &[::core::fmt::ArgumentV1::new_debug(&_0)])),
                WSError::NotImplemented {} =>
                    __formatter.write_fmt(::core::fmt::Arguments::new_v1(&["Not Implemented"],
                            &[])),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for WSError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                WSError::WsNetworkLogicErr(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "WsNetworkLogicErr", &__self_0),
                WSError::WsNetworkConnErr(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "WsNetworkConnErr", &__self_0),
                WSError::WsRaftErr(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "WsRaftErr", &__self_0),
                WSError::WsSerialErr(__self_0) =>
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f,
                        "WsSerialErr", &__self_0),
                WSError::NotImplemented =>
                    ::core::fmt::Formatter::write_str(f, "NotImplemented"),
            }
        }
    }
    impl From<WsNetworkLogicErr> for WSError {
        fn from(e: WsNetworkLogicErr) -> Self {
            WSError::WsNetworkLogicErr(e)
        }
    }
    impl From<WsNetworkConnErr> for WSError {
        fn from(e: WsNetworkConnErr) -> Self { WSError::WsNetworkConnErr(e) }
    }
    impl From<WsRaftErr> for WSError {
        fn from(e: WsRaftErr) -> Self { WSError::WsRaftErr(e) }
    }
    impl From<WsSerialErr> for WSError {
        fn from(e: WsSerialErr) -> Self { WSError::WsSerialErr(e) }
    }
    pub struct ErrCvt<T>(pub T);
    macro_rules! impl_err_convertor {
        ($t : ty, $sub_t : ty, $sub_tt : ty) =>
        {
            paste!
            {
                impl ErrCvt < $t >
                {
                    pub fn [< to_ $sub_t : snake >] (self) -> WSError
                    { WSError :: $sub_t($sub_t :: $sub_tt(self.0)) }
                }
            }
        } ;
    }
    impl ErrCvt<DecodeError> {
        pub fn to_ws_network_logic_err(self) -> WSError {
            WSError::WsNetworkLogicErr(WsNetworkLogicErr::DecodeError(self.0))
        }
    }
    impl ErrCvt<EndpointError> {
        pub fn to_ws_network_conn_err(self) -> WSError {
            WSError::WsNetworkConnErr(WsNetworkConnErr::EndPointError(self.0))
        }
    }
    impl ErrCvt<SendError> {
        pub fn to_ws_network_conn_err(self) -> WSError {
            WSError::WsNetworkConnErr(WsNetworkConnErr::SendError(self.0))
        }
    }
    impl ErrCvt<InitializeError> {
        pub fn to_ws_raft_err(self) -> WSError {
            WSError::WsRaftErr(WsRaftErr::InitializeError(self.0))
        }
    }
    impl ErrCvt<RaftError> {
        pub fn to_ws_raft_err(self) -> WSError {
            WSError::WsRaftErr(WsRaftErr::RaftError(self.0))
        }
    }
}
mod sys {
    use crate::{
        config::Config,
        kv::{
            dist_kv::KVNode,
            kv_client::{
                local_kv_client::LocalKVClient, meta_kv_client::MetaKVClient,
                KVClient,
            },
            local_kv::local_kv::LocalKVNode,
        },
    };
    use async_trait::async_trait;
    use std::{cell::RefCell, net::SocketAddr, sync::{Arc, Weak}};
    use crate::{result::WSResult, util::JoinHandleWrapper};
    pub struct Sys {
        pub logical_modules: Arc<LogicalModules>,
        sub_tasks: RefCell<Vec<JoinHandleWrapper>>,
    }
    impl Sys {
        pub fn new(config: Config) -> Sys {
            Sys {
                logical_modules: LogicalModules::new(LogicalNodeConfig {
                        as_scheduler: true,
                        as_data_router: true,
                        as_kv: true,
                        peers: config.peers.clone(),
                        this: config.this,
                    }),
                sub_tasks: Vec::new().into(),
            }
        }
        pub async fn wait_for_end(&self) {
            if let Err(err) = self.logical_modules.start(self).await {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite =
                            {
                                static META: ::tracing::Metadata<'static> =
                                    {
                                        ::tracing_core::metadata::Metadata::new("event src/sys.rs:47",
                                            "wasm_serverless::sys", ::tracing::Level::ERROR,
                                            ::core::option::Option::Some("src/sys.rs"),
                                            ::core::option::Option::Some(47u32),
                                            ::core::option::Option::Some("wasm_serverless::sys"),
                                            ::tracing_core::field::FieldSet::new(&["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE)),
                                            ::tracing::metadata::Kind::EVENT)
                                    };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                        let enabled =
                            ::tracing::Level::ERROR <=
                                        ::tracing::level_filters::STATIC_MAX_LEVEL &&
                                    ::tracing::Level::ERROR <=
                                        ::tracing::level_filters::LevelFilter::current() &&
                                {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never() &&
                                        ::tracing::__macro_support::__is_enabled(__CALLSITE.metadata(),
                                            interest)
                                };
                        if enabled {
                                (|value_set: ::tracing::field::ValueSet|
                                            {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                                ;
                                            })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE.metadata().fields().value_set(&[(&::core::iter::Iterator::next(&mut iter).expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(&::core::fmt::Arguments::new_v1(&["start logical nodes error: "],
                                                                            &[::core::fmt::ArgumentV1::new_debug(&err)]) as
                                                                    &dyn Value))])
                                    });
                            } else { ; }
                    };
                }
            for task in self.sub_tasks.borrow_mut().iter_mut() {
                task.join().await;
            }
        }
    }
    pub type NodeID = u32;
    pub struct LogicalNodeConfig {
        as_scheduler: bool,
        as_data_router: bool,
        as_kv: bool,
        peers: Vec<(SocketAddr, NodeID)>,
        this: (SocketAddr, NodeID),
    }
    pub struct LogicalModuleNewArgs {
        pub parent_name: String,
        pub btx: BroadcastSender,
        pub logical_models: Option<Weak<LogicalModules>>,
        pub peers_this: Option<(Vec<(SocketAddr, NodeID)>,
        (SocketAddr, NodeID))>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LogicalModuleNewArgs {
        #[inline]
        fn clone(&self) -> LogicalModuleNewArgs {
            LogicalModuleNewArgs {
                parent_name: ::core::clone::Clone::clone(&self.parent_name),
                btx: ::core::clone::Clone::clone(&self.btx),
                logical_models: ::core::clone::Clone::clone(&self.logical_models),
                peers_this: ::core::clone::Clone::clone(&self.peers_this),
            }
        }
    }
    impl LogicalModuleNewArgs {
        pub fn expand_parent_name(&mut self, this_name: &str) {
            let name =
                {
                    let res =
                        ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&["",
                                            "::"],
                                &[::core::fmt::ArgumentV1::new_display(&self.parent_name),
                                            ::core::fmt::ArgumentV1::new_display(&this_name)]));
                    res
                };
            self.parent_name = name;
        }
    }
    pub trait LogicalModule {
        fn inner_new(args: LogicalModuleNewArgs)
        -> Self
        where
        Self: Sized;
        #[must_use]
        #[allow(clippy :: type_complexity, clippy ::
        type_repetition_in_bounds)]
        fn start<'life0, 'async_trait>(&'life0 self)
        ->
            ::core::pin::Pin<Box<dyn ::core::future::Future<Output =
            WSResult<Vec<JoinHandleWrapper>>> + ::core::marker::Send +
            'async_trait>>
        where
        'life0: 'async_trait,
        Self: 'async_trait;
    }
    pub enum BroadcastMsg { SysEnd, }
    #[automatically_derived]
    impl ::core::clone::Clone for BroadcastMsg {
        #[inline]
        fn clone(&self) -> BroadcastMsg { BroadcastMsg::SysEnd }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BroadcastMsg {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "SysEnd")
        }
    }
    pub type BroadcastSender = tokio::sync::broadcast::Sender<BroadcastMsg>;
    macro_rules! logical_modules_ref_impl {
        ($module : ident, $type : ty) =>
        {
            impl LogicalModulesRef
            {
                fn $module(& self) -> & $type
                {
                    unsafe
                    {
                        (*
                        self.inner.as_ref().unwrap().as_ptr()).$module.as_ref().unwrap()
                    }
                }
            }
        } ;
    }
    macro_rules! logical_modules {
        ($($modules : ident, $ts : ty), +) =>
        { pub struct LogicalModules { $(pub $modules : Option < $ts >), + } }
    }
    pub struct LogicalModules {
        pub meta_kv_client: Option<Box<dyn KVClient>>,
        pub local_kv_client: Option<Box<dyn KVClient>>,
        pub local_kv: Option<Option<Box<dyn KVNode>>>,
    }
    struct LogicalModulesRef {
        inner: Option<Weak<LogicalModules>>,
    }
    impl LogicalModulesRef {
        fn setup(&mut self, modules: Arc<LogicalModules>) {
            self.inner = Some(Arc::downgrade(&modules));
        }
    }
    macro_rules! logical_module_view_impl {
        ($module : ident, $module_name : ident, $type : ty) =>
        {
            impl $module
            {
                pub fn $module_name(& self) -> & $type
                { self.inner.$module_name() }
            }
        } ; ($module : ident) =>
        {
            pub struct $module { inner : LogicalModulesRef, } impl $module
            {
                pub fn new() -> Self
                { $module { inner : LogicalModulesRef { inner : None }, } } fn
                setup(& mut self, modules : Arc < LogicalModules >)
                { self.inner.setup(modules) ; }
            }
        } ;
    }
    impl LogicalModulesRef {
        fn meta_kv_client(&self) -> &Box<dyn KVClient> {
            unsafe {
                (*self.inner.as_ref().unwrap().as_ptr()).meta_kv_client.as_ref().unwrap()
            }
        }
    }
    impl LogicalModulesRef {
        fn local_kv_client(&self) -> &Box<dyn KVClient> {
            unsafe {
                (*self.inner.as_ref().unwrap().as_ptr()).local_kv_client.as_ref().unwrap()
            }
        }
    }
    impl LogicalModulesRef {
        fn local_kv(&self) -> &Option<Box<dyn KVNode>> {
            unsafe {
                (*self.inner.as_ref().unwrap().as_ptr()).local_kv.as_ref().unwrap()
            }
        }
    }
    pub struct MetaKVClientView {
        inner: LogicalModulesRef,
    }
    impl MetaKVClientView {
        pub fn new() -> Self {
            MetaKVClientView { inner: LogicalModulesRef { inner: None } }
        }
        fn setup(&mut self, modules: Arc<LogicalModules>) {
            self.inner.setup(modules);
        }
    }
    impl MetaKVClientView {
        pub fn meta_kv_client(&self) -> &Box<dyn KVClient> {
            self.inner.meta_kv_client()
        }
    }
    impl LogicalModules {
        pub fn new(_config: LogicalNodeConfig) -> Arc<LogicalModules> {
            let (broadcast_tx, _broadcast_rx) =
                tokio::sync::broadcast::channel::<BroadcastMsg>(1);
            let args =
                LogicalModuleNewArgs {
                    btx: broadcast_tx,
                    logical_models: None,
                    parent_name: "".to_owned(),
                    peers_this: None,
                };
            let arc =
                LogicalModules {
                    meta_kv_client: Some(Box::new(MetaKVClient::new(args.clone()))),
                    local_kv_client: Some(Box::new(LocalKVClient::new(args.clone()))),
                    local_kv: Some({
                            let local_kv: Box<dyn KVNode> =
                                Box::new(LocalKVNode::new(args.clone()));
                            Some(local_kv)
                        }),
                };
            let arc = Arc::new(arc);
            arc
        }
        pub async fn start(&self, _sys: &Sys) -> WSResult<()> { Ok(()) }
    }
}
pub mod util {
    pub enum JoinHandleWrapper {
        Task(Option<tokio::task::JoinHandle<()>>),
        Thread(Option<std::thread::JoinHandle<()>>),
    }
    impl From<tokio::task::JoinHandle<()>> for JoinHandleWrapper {
        fn from(handle: tokio::task::JoinHandle<()>) -> Self {
            Self::Task(handle.into())
        }
    }
    impl From<std::thread::JoinHandle<()>> for JoinHandleWrapper {
        fn from(handle: std::thread::JoinHandle<()>) -> Self {
            Self::Thread(handle.into())
        }
    }
    impl JoinHandleWrapper {
        pub async fn join(&mut self) {
            match self {
                Self::Task(handle) => handle.take().unwrap().await.unwrap(),
                Self::Thread(handle) => {
                    let handle = handle.take().unwrap();
                    tokio::task::spawn_blocking(||
                                    handle.join().unwrap()).await.unwrap()
                }
            }
        }
    }
}
fn main() {
    let body =
        async {
            let my_filter =
                tracing_subscriber::filter::filter_fn(|v|
                        { v.level() == &tracing::Level::INFO });
            let my_layer = tracing_subscriber::fmt::layer();
            tracing_subscriber::registry().with(my_layer.with_filter(my_filter)).init();
            let args = CmdArgs::parse();
            let config = config::read_config(args.config_file);
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite =
                    {
                        static META: ::tracing::Metadata<'static> =
                            {
                                ::tracing_core::metadata::Metadata::new("event src/main.rs:72",
                                    "wasm_serverless", ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src/main.rs"),
                                    ::core::option::Option::Some(72u32),
                                    ::core::option::Option::Some("wasm_serverless"),
                                    ::tracing_core::field::FieldSet::new(&["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE)),
                                    ::tracing::metadata::Kind::EVENT)
                            };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                let enabled =
                    ::tracing::Level::INFO <=
                                ::tracing::level_filters::STATIC_MAX_LEVEL &&
                            ::tracing::Level::INFO <=
                                ::tracing::level_filters::LevelFilter::current() &&
                        {
                            let interest = __CALLSITE.interest();
                            !interest.is_never() &&
                                ::tracing::__macro_support::__is_enabled(__CALLSITE.metadata(),
                                    interest)
                        };
                if enabled {
                        (|value_set: ::tracing::field::ValueSet|
                                    {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                        ;
                                    })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE.metadata().fields().value_set(&[(&::core::iter::Iterator::next(&mut iter).expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(&::core::fmt::Arguments::new_v1(&["config: "],
                                                                    &[::core::fmt::ArgumentV1::new_debug(&config)]) as
                                                            &dyn Value))])
                            });
                    } else { ; }
            };
            Sys::new(config).wait_for_end().await;
        };

    #[allow(clippy :: expect_used, clippy :: diverging_sub_expression)]
    {
        return tokio::runtime::Builder::new_multi_thread().enable_all().build().expect("Failed building the Runtime").block_on(body);
    }
}
